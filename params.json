{"name":"Pedal-loader","tagline":"A Groovy DSL for easy data loading, particularly suited to database unit-testing.","body":"pedal-loader\r\n============\r\n\r\nA Groovy DSL for data loading that is particularly suited for database unit-testing. The load scripts work at the JPA entity level (not database columns and values but JPA entity properties and higher-level types). \r\n\r\n## Getting started\r\n\r\nDownload the pedal-loader jar from Maven central:\r\n\r\n```\r\n\t<groupId>com.eclecticlogic</groupId>\r\n\t<artifactId>pedal-loader</artifactId>\r\n\t<version>1.0.0</version>\r\n```\r\n\r\nMinimum dependencies that you need to provide in your application:\r\n\r\n1. slf4j (over logback or log4j) v1.7.7 or higher\r\n2. Spring boot jpa edition or\r\n4. hibernate-core and hibernate-entitymanager 4.3 or higher.\r\n5. JDBC4 compliant driver.\r\n6. groovy-all.jar 2.3 or above\r\n\r\n\r\n### Configuration \r\n\r\n#### Vanilla setup\r\n\r\nCreate an instance of `Loader` (concrete class `com.eclecticlogic.pedal.loader.impl.LoaderImpl`) and give it a reference to an `EntityManager`. \r\n\r\n#### Spring \r\n\r\nIf you are using @ComponentScan, include the `com.eclecticlogic.pedal.loader` package in the packages to be scanned. If you are using a Spring managed unit test, setup your test as shown below:\r\n\r\n```\r\n\r\n     @RunWith(SpringJUnit4ClassRunner.class)\r\n     @SpringApplicationConfiguration(classes = JpaConfiguration.class)\r\n     public class MyDatabaseTest {\r\n\r\n    \t@Autowired\r\n    \tprivate Loader loader;\r\n\r\n\r\n\t    @Test\r\n    \t@Transactional\r\n\t    public void myTest() {\r\n            Map<String, Object> variables = loader //\r\n                .withScriptDirectory(\"<directory-with-scripts>\") // Classpath resource dir\r\n                .load(\"script-reference\"); \r\n            ...\r\n        }\r\n    }\r\n\r\n```\r\n  \r\n \r\n## Data Loading\r\n\r\nThe pedal data loader is accessed via the Loader interface. Create your load script as one or more groovy scripts in your classpath.\r\n\r\nThe Loader interface provides a number of methods to specify your script and input variables for the script. Here are some ways to launch the script:\r\n\r\n```\r\n\r\n    loader.withScriptDirectory(\"myScripts\").load(\"basicdata.groovy\");\r\n\r\n```\r\nThis specifies that the loader should read the script basicdata.groovy contained within a classpath directory called myScripts. The file could just as well have been specified with the directory as `myScripts\\basicdata.groovy`. However, the withScriptDirectory allows you to setup a well known directory and have all other calls simply reference the script by name without worry about relative paths.\r\n\r\n### Script Format\r\n\r\nThe scripts are simple groovy files. To insert rows into a table, use the table() method. The method takes two parameters and a closure:\r\n\r\n1. Class reference of JPA entity\r\n2. List of attributes names you want to populate.\r\n\r\nThe method returns a list of entities created in the closure.\r\n\r\nThe table method should have a closure should have one more more row lines:\r\n\r\n```\r\n\r\n   rowsCreated = table(MyEntity, ['id', 'name', 'age']) {\r\n\trow value1, value2, value3 ...\r\n    row value1, value2, value3 ....\r\n   }\r\n\r\n```\r\n\r\nThe values are what you'd populate in the JPA entity, not in the database. So for a foreign key, you'd pass the @JoinColumn object. For a character field mapped to an Enum, you'd pass the actual Enum\r\n\r\nHere is an example of a simple script to populate a table and then a child table (i.e., JPA entities called School and Student):\r\n\r\n```\r\n\timport com.test.School\r\n    import com.test.Student\r\n\timport com.test.SchoolType\r\n    import com.test.Gender\r\n\r\n\ttable(School, ['name', 'type', 'address']) {\r\n\t\trow 'Lee Elementary', SchoolType.ELEMENTARY, '1 Lee Rd'\r\n\t\trow 'Park View School', SchoolType.MIDDLE, '10 Elm Street'\r\n\t\thighSchool = row 'Mountain Top High', SchoolType.HIGH, '12 Dream Street'\r\n\t} \r\n\r\n\tprintln highSchool.id\r\n\r\n    myStudents = table(Student, ['name', 'gender', 'school']) {\r\n\t\trow 'Joe Schmuckately', Gender.MALE, highSchool\r\n    }\r\n\r\n    // myStudents is a list of all the rows created.\r\n\r\n\tfind(Student, 1)\r\n```     \r\n\r\nIf your script expects say a starting primary key value, you can easily pass it as an input:\r\n\r\n```\r\n    Map<String, Object inputs = new HashMap<>();\r\n    inputs.put(\"pkStart\", 123);\r\n   \tloader.withInputs(inputs).load(\"basicdata.groovy\", \"secondScript.groovy\");\r\n```\r\n\r\nThe value is now available as a property called pkStart to the script (and to `secondScript.groovy` as well) and can be referenced directly:\r\n\r\n```\r\n    table(School, ['id', 'name', 'type', 'address']) {\r\n\t\trow pkStart++, 'Lee Elementary', SchoolType.ELEMENTARY, '1 Lee Rd'\r\n\t\trow pkStart++, 'Park View School', SchoolType.MIDDLE, '10 Elm Street'\r\n\t\thighSchool = row pkStart++, 'Mountain Top High', SchoolType.HIGH, '12 Dream Street'\r\n\t} \r\n\t\r\n```    \r\n\r\nSometimes the groovy compiler can get confused in evaluating the syntax for the columns. To help the compiler, wrap the column values in parenthesis:\r\n\r\n```\r\n    table(School, ['id', 'name', 'type', 'address']) {\r\n\t\trow (pkStart++, 'Lee Elementary', SchoolType.ELEMENTARY, '1 Lee Rd')\r\n\t\trow (pkStart++, 'Park View School', SchoolType.MIDDLE, '10 Elm Street')\r\n\t\thighSchool = row (pkStart++, 'Mountain Top High', SchoolType.HIGH, '12 Dream Street')\r\n\t} \r\n```\r\n\r\nSince the scripts are groovy based, you can use all groovy control structures to help you populate your data:\r\n\r\n```\r\n\ttable(MyValue, ['id', 'value']) {\r\n\t\t10.times { i ->\r\n\t\t\trow i, i * 50\r\n    \t}\r\n\t}\r\n```\r\n\r\nWhen testing your database functionality, sometimes you need reference to data that already exists. This is particularly important if the data has a generated PK. In the example above we created schools and created a reference to the high school in a variable called `highSchool`. This variable (strictly speaking, property) is automatically returned to the caller in a map. The key is a string with the value `highSchool` and the value is an instance of School. \r\n\r\n*Note: Do not declare highschool using a type or `def` as shown:*\r\n\r\n```\r\n    table(School, ['id', 'name', 'type', 'address']) {\r\n\t\trow (pkStart++, 'Lee Elementary', SchoolType.ELEMENTARY, '1 Lee Rd')\r\n\t\trow (pkStart++, 'Park View School', SchoolType.MIDDLE, '10 Elm Street')\r\n\t\tdef highSchool = row (pkStart++, 'Mountain Top High', SchoolType.HIGH, '12 Dream Street')\r\n\t} \r\n```\r\n\r\nThis will make highSchool a local variable and it will not be returned to the caller. Of course, if you need to temporarily hold on to large collections that you don't want to return back to the calling script, then do mark them with a `def` or type.\r\n\r\nIf you are invoking multiple scripts and some of the scripts return values that are named the same, you can define namespaces for the scripts. If two scripts `myScript1.groovy` and `myScript2.groovy` both create a property called `x`, you can load the scripts with namespaces as shown:\r\n\r\n```\r\n\tMap<String, Object> variables = loader.withInputs(inputs).load(Script.with(\"myScript1.groovy\", \"a\"), Script.with(\"myScript2.groovy\", \"b\");\r\n\r\n    Map<String, Object> script1Vars = variables.get(\"a\");\r\n    Object x = script1Vars.get(\"x\");\r\n```\r\n\r\nYou can also call scripts from within scripts. Use the `load()` method. The load method accepts a list of script names or a map of `namespace:script-name`.\r\n\r\n```\r\n\r\n   \toutput = load('a': 'simple.loader.groovy', 'b': 'simple.loader.groovy')\t\r\n\tassert output.a.simple1.amount == 20\r\n\r\n\tmyIndex = 101\r\n\tinputReaderVars = withInput(['index': myIndex]).load('input.reader.groovy')\r\n\tassert inputReaderVars.inputReaderReturn.amount == 101000\r\n\r\n``` \r\n\r\nwhere `simple.loader.groovy` is:\r\n\r\n```\r\n\r\n\timport com.eclecticlogic.pedal.loader.dm.SimpleType\r\n\t\r\n\ttable(SimpleType, ['amount']) {\r\n\t    simple1 = row 10\r\n\t    simple2 = row 20\r\n\t}\r\n```  \r\n\r\nand `input.reader.groovy` is:\r\n\r\n```\r\n\r\n\timport com.eclecticlogic.pedal.loader.dm.SimpleType\r\n\r\n\ttable(SimpleType, ['amount']) {\r\n    \tinputReaderReturn = simple1 = row (1000 * index)\r\n\t    simple2 = row 2000\r\n\t}\r\n```\r\n\r\nVariables created in one script are available to the next script when multiple scripts are passed to the same load() call. The find method can be used to retrieve data that has been created by primary key.\r\n\r\n### Default row\r\n\r\nSometimes you want to set certain columns of each row to the same value or the value can easily be defined as an expression. Pedal makes it easy to avoid repeating the value of the column in each row by defining a \"default\" row closure:\r\n\r\n```\r\n\r\n        tone = table (MyTable, ['id', 'name', 'insertedOn']) {\r\n            defaultRow {\r\n                it.insertedOn = new Date()\r\n            }\r\n            row 1, 'Joe'\r\n\t\t\trow 2, 'Schmoe'\r\n\t\t\trow 3, 'Jane'\r\n\t\t\trow 4, 'Jack'\r\n        }\r\n\r\n\r\n```\r\n\r\n### Custom functions\r\n\r\nYou can define custom functions that should be available within the load script. To define a custom-function, use the `.withCustomMethod` method on Loader passing in a closure:\r\n\r\n```\r\n        Map<String, Object> variables = loader //\r\n                .withCustomMethod(\"doubler\", new Closure<Object>(this) {\r\n\r\n                    @Override\r\n                    public Object call(Object... args) {\r\n                        Integer i = (Integer) args[0];\r\n                        return i * 2;\r\n                    }\r\n                }).withScriptDirectory(\"loader\") //\r\n                .load(\"customMethod.loader.groovy\");\r\n\r\n```  \r\n\r\n`doubler` is now a custom-function that can be called within your script:\r\n\r\n\r\n```\r\n\r\n     myvar = doubler 200\r\n\r\n```\r\n\r\n### Find and Flush\r\n\r\nThe find(Class, id) method is available to your DSL scripts to load records by JPA entity class and primary key. The flush() method does what you would think it should - flush the JPA session to the database.\r\n\r\nSee the src/test/resources/loader folder of the pedal-loader source for more examples.\r\n","google":"UA-54980372-1","note":"Don't delete this file! It's used internally to help with page regeneration."}